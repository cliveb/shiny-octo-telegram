"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const path = require("path");
const express = require("express");
const request = require("request");
const clc = require("cli-color");
const http = require("http");
const getProjectId = require("../getProjectId");
const functionsConfig = require("../functionsConfig");
const utils = require("../utils");
const logger = require("../logger");
const track = require("../track");
const constants_1 = require("./constants");
const types_1 = require("./types");
const chokidar = require("chokidar");
const spawn = require("cross-spawn");
const child_process_1 = require("child_process");
const functionsEmulatorShared_1 = require("./functionsEmulatorShared");
const registry_1 = require("./registry");
const events_1 = require("events");
const EVENT_INVOKE = "functions:invoke";
const SERVICE_FIRESTORE = "firestore.googleapis.com";
class FunctionsEmulator {
    constructor(options, args) {
        this.options = options;
        this.args = args;
        this.projectId = "";
        this.functionsDir = "";
        this.nodeBinary = "";
        this.knownTriggerIDs = {};
        this.port = this.args.port || constants_1.Constants.getDefaultPort(types_1.Emulators.FUNCTIONS);
        this.projectId = getProjectId(this.options, false);
    }
    static getHttpFunctionUrl(port, projectId, name, region) {
        return `http://localhost:${port}/${projectId}/${region}/${name}`;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.functionsDir = path.join(this.options.config.projectDir, this.options.config.get("functions.source"));
            this.nodeBinary = yield askInstallNodeVersion(this.functionsDir);
            this.firebaseConfig = yield functionsConfig.getFirebaseConfig(this.options);
            const hub = express();
            hub.use((req, res, next) => {
                res.header("Access-Control-Allow-Origin", "*");
                res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
                let data = "";
                req.on("data", (chunk) => {
                    data += chunk;
                });
                req.on("end", () => {
                    req.rawBody = data;
                    next();
                });
            });
            hub.get("/", (req, res) => __awaiter(this, void 0, void 0, function* () {
                res.send(JSON.stringify(yield functionsEmulatorShared_1.getTriggersFromDirectory(this.projectId, this.functionsDir, this.firebaseConfig), null, 2));
            }));
            const internalRoute = "/functions/projects/:project_id/triggers/:trigger_name";
            const externalRoute = `/:project_id/:region/:trigger_name`;
            const functionRoutes = [
                internalRoute,
                `${internalRoute}/*`,
                externalRoute,
                `${externalRoute}/*`,
            ];
            const handler = (req, res) => __awaiter(this, void 0, void 0, function* () {
                const method = req.method;
                const triggerName = req.params.trigger_name;
                logger.debug(`[functions] ${method} request to function ${triggerName} accepted.`);
                const reqBody = req.rawBody;
                const proto = reqBody ? JSON.parse(reqBody) : undefined;
                const runtime = this.startFunctionRuntime(triggerName, proto);
                runtime.events.on("log", (el) => {
                    if (el.level === "FATAL") {
                        res.send(el.text);
                    }
                });
                const triggerLogPromise = waitForLog(runtime.events, "SYSTEM", "triggers-parsed");
                logger.debug(`[functions] Waiting for runtime to be ready!`);
                yield runtime.ready;
                logger.debug(JSON.stringify(runtime.metadata));
                const triggerLog = yield triggerLogPromise;
                const triggerMap = triggerLog.data.triggers;
                const trigger = triggerMap[triggerName];
                const isHttpsTrigger = trigger.definition.httpsTrigger ? true : false;
                if (isHttpsTrigger) {
                    track(EVENT_INVOKE, "https");
                }
                else {
                    const service = _.get(trigger.definition, "eventTrigger.service", "unknown");
                    track(EVENT_INVOKE, service);
                }
                if (!isHttpsTrigger) {
                    yield runtime.exit;
                    return res.json({ status: "acknowledged" });
                }
                logger.debug(`[functions] Runtime ready! Sending request! ${JSON.stringify(runtime.metadata)}`);
                const runtimeReq = http.request({
                    method,
                    path: req.url,
                    headers: req.headers,
                    socketPath: runtime.metadata.socketPath,
                }, (runtimeRes) => {
                    function forwardStatusAndHeaders() {
                        res.status(runtimeRes.statusCode || 200);
                        if (!res.headersSent) {
                            Object.keys(runtimeRes.headers).forEach((key) => {
                                const val = runtimeRes.headers[key];
                                if (val) {
                                    res.setHeader(key, val);
                                }
                            });
                        }
                    }
                    runtimeRes.on("data", (buf) => {
                        forwardStatusAndHeaders();
                        res.write(buf);
                    });
                    runtimeRes.on("close", () => {
                        forwardStatusAndHeaders();
                        res.end();
                    });
                    runtimeRes.on("end", () => {
                        forwardStatusAndHeaders();
                        res.end();
                    });
                });
                runtimeReq.on("error", () => {
                    res.end();
                });
                if (reqBody) {
                    runtimeReq.write(reqBody);
                    runtimeReq.end();
                }
                req
                    .pipe(runtimeReq, { end: true })
                    .on("error", () => {
                    res.end();
                });
                yield runtime.exit;
            });
            hub.get(functionRoutes, handler);
            hub.post(functionRoutes, handler);
            this.server = hub.listen(this.port);
        });
    }
    startFunctionRuntime(triggerName, proto) {
        const runtimeBundle = {
            ports: {
                firestore: registry_1.EmulatorRegistry.getPort(types_1.Emulators.FIRESTORE),
            },
            proto,
            cwd: this.functionsDir,
            triggerId: triggerName,
            projectId: this.projectId,
            disabled_features: this.args.disabledRuntimeFeatures,
        };
        const runtime = InvokeRuntime(this.nodeBinary, runtimeBundle);
        runtime.events.on("log", this.handleRuntimeLog.bind(this));
        return runtime;
    }
    handleSystemLog(systemLog) {
        switch (systemLog.type) {
            case "runtime-status":
                if (systemLog.text === "killed") {
                    utils.logWarning(`Your function was killed because it raised an unhandled error.`);
                }
                break;
            case "googleapis-network-access":
                utils.logWarning(`Google API requested!\n   - URL: "${systemLog.data.href}"\n   - Be careful, this may be a production service.`);
                break;
            case "unidentified-network-access":
                utils.logWarning(`Unknown network resource requested!\n   - URL: "${systemLog.data.href}"`);
                break;
            case "functions-config-missing-value":
                utils.logWarning(`Non-existent functions.config() value requested!\n   - Path: "${systemLog.data.valuePath}"\n   - Learn more at https://firebase.google.com/docs/functions/local-emulator`);
                break;
            case "default-admin-app-used":
                utils.logWarning(`Default "firebase-admin" instance created!`);
                break;
            case "non-default-admin-app-used":
                utils.logWarning(`Non-default "firebase-admin" instance created!\n   ` +
                    `- This instance will *not* be mocked and will access production resources.`);
                break;
            case "missing-module":
                utils.logWarning(`The Cloud Functions emulator requires the module "${systemLog.data.name}" to be installed as a ${systemLog.data.isDev ? "development dependency" : "dependency"}. To fix this, run "npm install ${systemLog.data.isDev ? "--save-dev" : "--save"} ${systemLog.data.name}" in your functions directory.`);
                break;
            case "uninstalled-module":
                utils.logWarning(`The Cloud Functions emulator requires the module "${systemLog.data.name}" to be installed. This package is in your package.json, but it's not available. \
You probably need to run "npm install" in your functions directory.`);
                break;
            case "out-of-date-module":
                utils.logWarning(`The Cloud Functions emulator requires the module "${systemLog.data.name}" to be version >${systemLog.data.minVersion}.0.0 so your version is too old. \
You can probably fix this by running "npm install ${systemLog.data.name}@latest" in your functions directory.`);
                break;
            case "missing-package-json":
                utils.logWarning(`The Cloud Functions directory you specified does not have a "package.json" file, so we can't load it.`);
                break;
            case "missing-package-json":
                utils.logWarning(`The Cloud Functions directory you specified does not have a "package.json" file, so we can't load it.`);
                break;
            case "admin-not-initialized":
                utils.logWarning("The Firebase Admin module has not been initialized early enough. Make sure you run " +
                    '"admin.initializeApp()" outside of any function and at the top of your code');
                break;
            default:
        }
    }
    handleRuntimeLog(log, ignore = []) {
        if (ignore.indexOf(log.level) >= 0) {
            return;
        }
        switch (log.level) {
            case "SYSTEM":
                this.handleSystemLog(log);
                break;
            case "USER":
                logger.info(`${clc.blackBright("> ")} ${log.text}`);
                break;
            case "DEBUG":
                logger.debug(log.text);
                break;
            case "INFO":
                utils.logLabeledBullet("functions", log.text);
                break;
            case "WARN":
                utils.logWarning(log.text);
                break;
            case "FATAL":
                utils.logWarning(log.text);
                break;
            default:
                logger.info(`${log.level}: ${log.text}`);
                break;
        }
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            utils.logLabeledBullet("functions", `Watching "${this.functionsDir}" for Cloud Functions...`);
            const watcher = chokidar.watch(this.functionsDir, {
                ignored: [
                    /(^|[\/\\])\../,
                    /.+\.log/,
                ],
                persistent: true,
            });
            const diagnosticBundle = {
                cwd: this.functionsDir,
                projectId: this.projectId,
                triggerId: "",
                ports: {},
                disabled_features: this.args.disabledRuntimeFeatures,
            };
            const loadTriggers = () => __awaiter(this, void 0, void 0, function* () {
                const runtime = InvokeRuntime(this.nodeBinary, diagnosticBundle);
                runtime.events.on("log", (el) => {
                    this.handleRuntimeLog(el);
                });
                const triggerParseEvent = yield waitForLog(runtime.events, "SYSTEM", "triggers-parsed");
                const triggerDefinitions = triggerParseEvent.data
                    .triggerDefinitions;
                const toSetup = triggerDefinitions.filter((definition) => !this.knownTriggerIDs[definition.name]);
                for (const definition of toSetup) {
                    if (definition.httpsTrigger) {
                        const region = functionsEmulatorShared_1.getFunctionRegion(definition);
                        const url = FunctionsEmulator.getHttpFunctionUrl(this.port, this.projectId, definition.name, region);
                        utils.logLabeledBullet("functions", `HTTP trigger initialized at ${clc.bold(url)}`);
                    }
                    else {
                        const service = _.get(definition, "eventTrigger.service", "unknown");
                        switch (service) {
                            case SERVICE_FIRESTORE:
                                yield this.addFirestoreTrigger(this.projectId, definition);
                                break;
                            default:
                                logger.debug(`Unsupported trigger: ${JSON.stringify(definition)}`);
                                utils.logWarning(`Ignoring trigger "${definition.name}" because the service "${service}" is not yet supported.`);
                                break;
                        }
                    }
                    this.knownTriggerIDs[definition.name] = true;
                }
            });
            const debouncedLoadTriggers = _.debounce(loadTriggers, 1000);
            watcher.on("change", (filePath) => {
                logger.debug(`File ${filePath} changed, reloading triggers`);
                return debouncedLoadTriggers();
            });
            return loadTriggers();
        });
    }
    addFirestoreTrigger(projectId, definition) {
        const firestorePort = registry_1.EmulatorRegistry.getPort(types_1.Emulators.FIRESTORE);
        if (!firestorePort) {
            utils.logWarning(`Ignoring trigger "${definition.name}" because the Cloud Firestore emulator is not running.`);
            return Promise.resolve();
        }
        const bundle = JSON.stringify({ eventTrigger: definition.eventTrigger });
        utils.logLabeledBullet("functions", `Setting up Cloud Firestore trigger "${definition.name}"`);
        return new Promise((resolve, reject) => {
            request.put(`http://localhost:${firestorePort}/emulator/v1/projects/${projectId}/triggers/${definition.name}`, {
                body: bundle,
            }, (err, res, body) => {
                if (err) {
                    utils.logWarning("Error adding trigger: " + err);
                    reject();
                    return;
                }
                if (JSON.stringify(JSON.parse(body)) === "{}") {
                    utils.logLabeledSuccess("functions", `Trigger "${definition.name}" has been acknowledged by the Cloud Firestore emulator.`);
                }
                resolve();
            });
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            Promise.resolve(this.server && this.server.close());
        });
    }
    getInfo() {
        const host = this.args.host || constants_1.Constants.getDefaultHost(types_1.Emulators.FUNCTIONS);
        const port = this.args.port || constants_1.Constants.getDefaultPort(types_1.Emulators.FUNCTIONS);
        return {
            host,
            port,
        };
    }
    getName() {
        return types_1.Emulators.FUNCTIONS;
    }
}
exports.FunctionsEmulator = FunctionsEmulator;
function InvokeRuntime(nodeBinary, frb, opts) {
    opts = opts || {};
    const emitter = new events_1.EventEmitter();
    const metadata = {};
    const runtime = spawn(nodeBinary, [
        path.join(__dirname, "functionsEmulatorRuntime"),
        JSON.stringify(frb),
        opts.serializedTriggers || "",
    ], { env: Object.assign({ node: nodeBinary }, opts.env, process.env), cwd: frb.cwd });
    const buffers = { stderr: { pipe: runtime.stderr, value: "" }, stdout: { pipe: runtime.stdout, value: "" } };
    for (const id in buffers) {
        if (buffers.hasOwnProperty(id)) {
            const buffer = buffers[id];
            buffer.pipe.on("data", (buf) => {
                buffer.value += buf;
                const lines = buffer.value.split("\n");
                if (lines.length > 1) {
                    lines.slice(0, -1).forEach((line) => {
                        const log = types_1.EmulatorLog.fromJSON(line);
                        emitter.emit("log", log);
                        if (log.level === "FATAL") {
                            emitter.emit("log", new types_1.EmulatorLog("SYSTEM", "runtime-status", "killed"));
                            runtime.kill();
                        }
                    });
                }
                buffer.value = lines[lines.length - 1];
            });
        }
    }
    const ready = waitForLog(emitter, "SYSTEM", "runtime-status", (log) => {
        return log.text === "ready";
    }).then((el) => {
        metadata.socketPath = el.data.socketPath;
    });
    return {
        exit: new Promise((resolve) => {
            runtime.on("exit", resolve);
        }),
        ready,
        metadata,
        events: emitter,
        kill: (signal) => {
            runtime.kill(signal);
            emitter.emit("log", new types_1.EmulatorLog("SYSTEM", "runtime-status", "killed"));
        },
    };
}
exports.InvokeRuntime = InvokeRuntime;
function waitForLog(emitter, level, type, filter) {
    return new Promise((resolve, reject) => {
        emitter.on("log", (el) => {
            const levelTypeMatch = el.level === level && el.type === type;
            let filterMatch = true;
            if (filter) {
                filterMatch = filter(el);
            }
            if (levelTypeMatch && filterMatch) {
                resolve(el);
            }
        });
    });
}
function askInstallNodeVersion(cwd) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkg = require(path.join(cwd, "package.json"));
        if (!pkg.engines || !pkg.engines.node) {
            utils.logWarning("Your functions directory does not specify a Node version.\n   " +
                "- Learn more at https://firebase.google.com/docs/functions/manage-functions#set_runtime_options");
            return process.execPath;
        }
        const hostMajorVersion = process.versions.node.split(".")[0];
        const requestedMajorVersion = pkg.engines.node;
        let localMajorVersion = "0";
        const localNodePath = path.join(cwd, "node_modules/.bin/node");
        try {
            const localNodeOutput = child_process_1.spawnSync(localNodePath, ["--version"]).stdout.toString();
            localMajorVersion = localNodeOutput.slice(1).split(".")[0];
        }
        catch (err) {
        }
        if (requestedMajorVersion === hostMajorVersion) {
            utils.logLabeledSuccess("functions", `Using node@${requestedMajorVersion} from host.`);
            return process.execPath;
        }
        if (localMajorVersion === requestedMajorVersion) {
            utils.logLabeledSuccess("functions", `Using node@${requestedMajorVersion} from local cache.`);
            return localNodePath;
        }
        utils.logWarning(`Your requested "node" version "${requestedMajorVersion}" doesn't match your global version "${hostMajorVersion}"`);
        return process.execPath;
    });
}
//# sourceMappingURL=functionsEmulator.js.map