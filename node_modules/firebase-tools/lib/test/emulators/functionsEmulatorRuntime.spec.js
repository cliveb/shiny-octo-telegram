"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const functionsEmulator_1 = require("../../emulator/functionsEmulator");
const http_1 = require("http");
const functionsEmulatorShared_1 = require("../../emulator/functionsEmulatorShared");
const cwd = functionsEmulatorShared_1.findModuleRoot("firebase-tools", __dirname);
const FunctionRuntimeBundles = {
    onCreate: {
        ports: {
            firestore: 8080,
        },
        cwd,
        proto: {
            data: {
                value: {
                    name: "projects/fake-project-id/databases/(default)/documents/test/test",
                    fields: {
                        when: {
                            timestampValue: "2019-04-15T16:55:48.150Z",
                        },
                    },
                    createTime: "2019-04-15T16:56:13.737Z",
                    updateTime: "2019-04-15T16:56:13.737Z",
                },
                updateMask: {},
            },
            context: {
                eventId: "7ebfb089-f549-4e1f-8312-fe843efc8be7",
                timestamp: "2019-04-15T16:56:13.737Z",
                eventType: "providers/cloud.firestore/eventTypes/document.create",
                resource: {
                    name: "projects/fake-project-id/databases/(default)/documents/test/test",
                    service: "firestore.googleapis.com",
                },
            },
        },
        triggerId: "function_id",
        projectId: "fake-project-id",
    },
    onWrite: {
        ports: {
            firestore: 8080,
        },
        cwd,
        proto: {
            data: {
                value: {
                    name: "projects/fake-project-id/databases/(default)/documents/test/test",
                    fields: {
                        when: {
                            timestampValue: "2019-04-15T16:55:48.150Z",
                        },
                    },
                    createTime: "2019-04-15T16:56:13.737Z",
                    updateTime: "2019-04-15T16:56:13.737Z",
                },
                updateMask: {},
            },
            context: {
                eventId: "7ebfb089-f549-4e1f-8312-fe843efc8be7",
                timestamp: "2019-04-15T16:56:13.737Z",
                eventType: "providers/cloud.firestore/eventTypes/document.write",
                resource: {
                    name: "projects/fake-project-id/databases/(default)/documents/test/test",
                    service: "firestore.googleapis.com",
                },
            },
        },
        triggerId: "function_id",
        projectId: "fake-project-id",
    },
    onDelete: {
        ports: {
            firestore: 8080,
        },
        cwd,
        proto: {
            data: {
                oldValue: {
                    name: "projects/fake-project-id/databases/(default)/documents/test/test",
                    fields: {
                        when: {
                            timestampValue: "2019-04-15T16:55:48.150Z",
                        },
                    },
                    createTime: "2019-04-15T16:56:13.737Z",
                    updateTime: "2019-04-15T16:56:13.737Z",
                },
                updateMask: {},
            },
            context: {
                eventId: "7ebfb089-f549-4e1f-8312-fe843efc8be7",
                timestamp: "2019-04-15T16:56:13.737Z",
                eventType: "providers/cloud.firestore/eventTypes/document.delete",
                resource: {
                    name: "projects/fake-project-id/databases/(default)/documents/test/test",
                    service: "firestore.googleapis.com",
                },
            },
        },
        triggerId: "function_id",
        projectId: "fake-project-id",
    },
    onRequest: {
        ports: {
            firestore: 8080,
        },
        cwd,
        triggerId: "function_id",
        projectId: "fake-project-id",
    },
};
function _countLogEntries(runtime) {
    return __awaiter(this, void 0, void 0, function* () {
        const counts = {};
        runtime.events.on("log", (el) => {
            counts[el.type] = (counts[el.type] || 0) + 1;
        });
        yield runtime.exit;
        return counts;
    });
}
function _is_verbose(runtime) {
    runtime.events.on("log", (el) => {
        process.stdout.write(el.toPrettyString() + "\n");
    });
}
const TIMEOUT_LONG = 10000;
const TIMEOUT_MED = 5000;
describe("FunctionsEmulatorRuntime", () => {
    describe("Stubs, Mocks, and Helpers (aka Magic, Glee, and Awesomeness)", () => {
        describe("_InitializeNetworkFiltering(...)", () => {
            it("should log outgoing HTTPS requests", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onCreate(() => __awaiter(this, void 0, void 0, function* () {
                            yield Promise.all([
                                require("node-fetch")("https://httpstat.us/302"),
                                require("node-fetch")("https://storage.googleapis.com/"),
                                new Promise((resolve) => {
                                    require("http").get("http://example.com", resolve);
                                }),
                                new Promise((resolve) => {
                                    require("https").get("https://example.com", resolve);
                                }),
                            ]);
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onCreate, {
                    serializedTriggers,
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["unidentified-network-access"]).to.gte(3);
                chai_1.expect(logs["googleapis-network-access"]).to.gte(1);
            })).timeout(TIMEOUT_LONG);
        });
        describe("_InitializeFirebaseAdminStubs(...)", () => {
            it("should provide stubbed default app from initializeApp", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onCreate(() => __awaiter(this, void 0, void 0, function* () { })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onCreate, {
                    serializedTriggers,
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["default-admin-app-used"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
            it("should provide non-stubbed non-default app from initializeApp", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    require("firebase-admin").initializeApp({}, "non-default");
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onCreate(() => __awaiter(this, void 0, void 0, function* () { })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onCreate, {
                    serializedTriggers,
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["non-default-admin-app-used"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
            it("should alert when the app is not initialized", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onCreate(() => __awaiter(this, void 0, void 0, function* () {
                            require("firebase-admin")
                                .firestore()
                                .doc("a/b")
                                .get();
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onCreate, {
                    serializedTriggers,
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["admin-not-initialized"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
            it("should route all sub-fields accordingly", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onCreate(() => __awaiter(this, void 0, void 0, function* () {
                            console.log(JSON.stringify(require("firebase-admin").firestore.FieldValue.increment(4)));
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onCreate, {
                    serializedTriggers,
                });
                runtime.events.on("log", (el) => {
                    if (el.level !== "USER") {
                        return;
                    }
                    chai_1.expect(JSON.parse(el.text)).to.deep.eq({ operand: 4 });
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["function-log"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
            it("should redirect Firestore write to emulator", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    const admin = require("firebase-admin");
                    admin.initializeApp();
                    return {
                        function_id: require("firebase-functions").https.onRequest((req, res) => __awaiter(this, void 0, void 0, function* () {
                            try {
                                yield admin
                                    .firestore()
                                    .collection("test")
                                    .add({ date: new Date() });
                                res.json({ from_trigger: true });
                            }
                            catch (e) {
                                res.json({ error: e.message });
                            }
                        })),
                    };
                }).toString();
                const onRequestCopy = JSON.parse(JSON.stringify(FunctionRuntimeBundles.onRequest));
                onRequestCopy.ports = { firestore: 80800 };
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, onRequestCopy, {
                    serializedTriggers,
                });
                yield runtime.ready;
                yield new Promise((resolve) => {
                    http_1.request({
                        socketPath: runtime.metadata.socketPath,
                        path: "/",
                    }, (res) => {
                        let data = "";
                        res.on("data", (chunk) => (data += chunk));
                        res.on("end", () => {
                            chai_1.expect(JSON.parse(data).error).to.exist;
                            resolve();
                        });
                    }).end();
                });
                yield runtime.exit;
            })).timeout(TIMEOUT_MED);
            it("should merge .settings() with emulator settings", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    const admin = require("firebase-admin");
                    admin.initializeApp();
                    admin.firestore().settings({
                        timestampsInSnapshots: true,
                    });
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onCreate(() => __awaiter(this, void 0, void 0, function* () { })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onCreate, {
                    serializedTriggers,
                });
                runtime.events.on("log", (el) => {
                    chai_1.expect(el.text.indexOf("You can only call settings() once")).to.eq(-1);
                });
                yield runtime.exit;
            })).timeout(TIMEOUT_MED);
            it("should merge .initializeApp arguments from user", () => __awaiter(this, void 0, void 0, function* () {
                if (process.env.CI) {
                    return;
                }
                const serializedTriggers = (() => {
                    const admin = require("firebase-admin");
                    admin.initializeApp({
                        databaseURL: "fake-app-id.firebaseio.com",
                    });
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onCreate((snap, ctx) => __awaiter(this, void 0, void 0, function* () {
                            admin
                                .database()
                                .ref("write-test")
                                .set({
                                date: new Date(),
                            });
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onCreate, {
                    serializedTriggers,
                });
                runtime.events.on("log", (el) => {
                    if (el.level !== "USER") {
                        return;
                    }
                    chai_1.expect(el.text.indexOf("Please ensure that you spelled the name of your " +
                        "Firebase correctly (https://fake-app-id.firebaseio.com)")).to.gte(0);
                    runtime.kill();
                });
                yield runtime.exit;
            })).timeout(TIMEOUT_MED);
        });
        describe("_InitializeFunctionsConfigHelper()", () => {
            it("should tell the user if they've accessed a non-existent function field", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onCreate(() => __awaiter(this, void 0, void 0, function* () {
                            console.log(require("firebase-functions").config().doesnt.exist);
                            console.log(require("firebase-functions").config().does.exist);
                            console.log(require("firebase-functions").config().also_doesnt.exist);
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onCreate, {
                    serializedTriggers,
                    env: {
                        CLOUD_RUNTIME_CONFIG: JSON.stringify({ does: { exist: "already exists" } }),
                    },
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["functions-config-missing-value"]).to.eq(2);
            })).timeout(TIMEOUT_MED);
        });
    });
    describe("Runtime", () => {
        describe("HTTPS", () => {
            it("should handle a single invocation", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions").https.onRequest((req, res) => __awaiter(this, void 0, void 0, function* () {
                            res.json({ from_trigger: true });
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onRequest, {
                    serializedTriggers,
                });
                yield runtime.ready;
                yield new Promise((resolve) => {
                    http_1.request({
                        socketPath: runtime.metadata.socketPath,
                        path: "/",
                    }, (res) => {
                        let data = "";
                        res.on("data", (chunk) => (data += chunk));
                        res.on("end", () => {
                            chai_1.expect(JSON.parse(data)).to.deep.equal({ from_trigger: true });
                            resolve();
                        });
                    }).end();
                });
                yield runtime.exit;
            })).timeout(TIMEOUT_MED);
        });
        describe("Cloud Firestore", () => {
            it("should provide Change for firestore.onWrite()", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onWrite((change) => __awaiter(this, void 0, void 0, function* () {
                            console.log(JSON.stringify({
                                before_exists: change.before.exists,
                                after_exists: change.after.exists,
                            }));
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onWrite, {
                    serializedTriggers,
                });
                runtime.events.on("log", (el) => {
                    if (el.level !== "USER") {
                        return;
                    }
                    chai_1.expect(JSON.parse(el.text)).to.deep.eq({ before_exists: false, after_exists: true });
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["function-log"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
            it("should provide Change for firestore.onUpdate()", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onUpdate((change) => __awaiter(this, void 0, void 0, function* () {
                            console.log(JSON.stringify({
                                before_exists: change.before.exists,
                                after_exists: change.after.exists,
                            }));
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onWrite, {
                    serializedTriggers,
                });
                runtime.events.on("log", (el) => {
                    if (el.level !== "USER") {
                        return;
                    }
                    chai_1.expect(JSON.parse(el.text)).to.deep.eq({ before_exists: false, after_exists: true });
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["function-log"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
            it("should provide DocumentSnapshot for firestore.onDelete()", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onDelete((snap) => __awaiter(this, void 0, void 0, function* () {
                            console.log(JSON.stringify({
                                snap_exists: snap.exists,
                            }));
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onDelete, {
                    serializedTriggers,
                });
                runtime.events.on("log", (el) => {
                    if (el.level !== "USER") {
                        return;
                    }
                    chai_1.expect(JSON.parse(el.text)).to.deep.eq({ snap_exists: true });
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["function-log"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
            it("should provide DocumentSnapshot for firestore.onCreate()", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions")
                            .firestore.document("test/test")
                            .onCreate((snap) => __awaiter(this, void 0, void 0, function* () {
                            console.log(JSON.stringify({
                                snap_exists: snap.exists,
                            }));
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onWrite, {
                    serializedTriggers,
                });
                runtime.events.on("log", (el) => {
                    if (el.level !== "USER") {
                        return;
                    }
                    chai_1.expect(JSON.parse(el.text)).to.deep.eq({ snap_exists: true });
                });
                const logs = yield _countLogEntries(runtime);
                chai_1.expect(logs["function-log"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
        });
        describe("Error handling", () => {
            it("Should handle regular functions for Express handlers", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions").https.onRequest((req, res) => {
                            global["not a thing"]();
                        }),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onRequest, {
                    serializedTriggers,
                });
                const logs = _countLogEntries(runtime);
                yield runtime.ready;
                yield new Promise((resolve) => {
                    http_1.request({
                        socketPath: runtime.metadata.socketPath,
                        path: "/",
                    }, (res) => {
                        res.on("end", resolve);
                        res.on("error", resolve);
                    })
                        .on("error", resolve)
                        .end();
                });
                yield runtime.exit;
                chai_1.expect((yield logs)["runtime-error"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
            it("Should handle async functions for Express handlers", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions").https.onRequest((req, res) => __awaiter(this, void 0, void 0, function* () {
                            global["not a thing"]();
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onRequest, {
                    serializedTriggers,
                });
                const logs = _countLogEntries(runtime);
                yield runtime.ready;
                yield new Promise((resolve) => {
                    http_1.request({
                        socketPath: runtime.metadata.socketPath,
                        path: "/",
                    }, (res) => {
                        res.on("end", resolve);
                        res.on("error", resolve);
                    })
                        .on("error", resolve)
                        .end();
                });
                yield runtime.exit;
                chai_1.expect((yield logs)["runtime-error"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
            it("Should handle async/runWith functions for Express handlers", () => __awaiter(this, void 0, void 0, function* () {
                const serializedTriggers = (() => {
                    require("firebase-admin").initializeApp();
                    return {
                        function_id: require("firebase-functions")
                            .runWith({})
                            .https.onRequest((req, res) => __awaiter(this, void 0, void 0, function* () {
                            global["not a thing"]();
                        })),
                    };
                }).toString();
                const runtime = functionsEmulator_1.InvokeRuntime(process.execPath, FunctionRuntimeBundles.onRequest, {
                    serializedTriggers,
                });
                const logs = _countLogEntries(runtime);
                yield runtime.ready;
                yield new Promise((resolve) => {
                    http_1.request({
                        socketPath: runtime.metadata.socketPath,
                        path: "/",
                    }, (res) => {
                        res.on("end", resolve);
                        res.on("error", resolve);
                    })
                        .on("error", resolve)
                        .end();
                });
                yield runtime.exit;
                chai_1.expect((yield logs)["runtime-error"]).to.eq(1);
            })).timeout(TIMEOUT_MED);
        });
    });
});
//# sourceMappingURL=functionsEmulatorRuntime.spec.js.map